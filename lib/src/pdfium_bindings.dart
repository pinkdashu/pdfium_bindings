// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to PDFium
class PDFiumBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  PDFiumBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  PDFiumBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Function: FPDF_InitLibrary
  /// Initialize the FPDFSDK library
  /// Parameters:
  /// None
  /// Return value:
  /// None.
  /// Comments:
  /// Convenience function to call FPDF_InitLibraryWithConfig() for
  /// backwards compatibility purposes. This will be deprecated in the
  /// future.
  void FPDF_InitLibrary() {
    return _FPDF_InitLibrary();
  }

  late final _FPDF_InitLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('FPDF_InitLibrary');
  late final _FPDF_InitLibrary =
      _FPDF_InitLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_InitLibraryWithConfig
  /// Initialize the FPDFSDK library
  /// Parameters:
  /// config - configuration information as above.
  /// Return value:
  /// None.
  /// Comments:
  /// You have to call this function before you can call any PDF
  /// processing functions.
  void FPDF_InitLibraryWithConfig(
    ffi.Pointer<FPDF_LIBRARY_CONFIG> config,
  ) {
    return _FPDF_InitLibraryWithConfig(
      config,
    );
  }

  late final _FPDF_InitLibraryWithConfigPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FPDF_LIBRARY_CONFIG>)>>('FPDF_InitLibraryWithConfig');
  late final _FPDF_InitLibraryWithConfig = _FPDF_InitLibraryWithConfigPtr
      .asFunction<void Function(ffi.Pointer<FPDF_LIBRARY_CONFIG>)>();

  /// Function: FPDF_DestroyLibary
  /// Release all resources allocated by the FPDFSDK library.
  /// Parameters:
  /// None.
  /// Return value:
  /// None.
  /// Comments:
  /// You can call this function to release all memory blocks allocated by
  /// the library.
  /// After this function is called, you should not call any PDF
  /// processing functions.
  void FPDF_DestroyLibrary() {
    return _FPDF_DestroyLibrary();
  }

  late final _FPDF_DestroyLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('FPDF_DestroyLibrary');
  late final _FPDF_DestroyLibrary =
      _FPDF_DestroyLibraryPtr.asFunction<void Function()>();

  /// Function: FPDF_SetSandBoxPolicy
  /// Set the policy for the sandbox environment.
  /// Parameters:
  /// policy -   The specified policy for setting, for example:
  /// FPDF_POLICY_MACHINETIME_ACCESS.
  /// enable -   True to enable, false to disable the policy.
  /// Return value:
  /// None.
  void FPDF_SetSandBoxPolicy(
    int policy,
    int enable,
  ) {
    return _FPDF_SetSandBoxPolicy(
      policy,
      enable,
    );
  }

  late final _FPDF_SetSandBoxPolicyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DWORD, FPDF_BOOL)>>(
          'FPDF_SetSandBoxPolicy');
  late final _FPDF_SetSandBoxPolicy =
      _FPDF_SetSandBoxPolicyPtr.asFunction<void Function(int, int)>();

  /// Experimental API.
  /// Function: FPDF_SetPrintMode
  /// Set printing mode when printing on Windows.
  /// Parameters:
  /// mode - FPDF_PRINTMODE_EMF to output EMF (default)
  /// FPDF_PRINTMODE_TEXTONLY to output text only (for charstream
  /// devices)
  /// FPDF_PRINTMODE_POSTSCRIPT2 to output level 2 PostScript into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT3 to output level 3 PostScript into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH to output level 2
  /// PostScript via ExtEscape() in PASSTHROUGH mode.
  /// FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH to output level 3
  /// PostScript via ExtEscape() in PASSTHROUGH mode.
  /// FPDF_PRINTMODE_EMF_IMAGE_MASKS to output EMF, with more
  /// efficient processing of documents containing image masks.
  /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42 to output level 3
  /// PostScript with embedded Type 42 fonts, when applicable, into
  /// EMF as a series of GDI comments.
  /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH to output level
  /// 3 PostScript with embedded Type 42 fonts, when applicable,
  /// via ExtEscape() in PASSTHROUGH mode.
  /// Return value:
  /// True if successful, false if unsuccessful (typically invalid input).
  int FPDF_SetPrintMode(
    int mode,
  ) {
    return _FPDF_SetPrintMode(
      mode,
    );
  }

  late final _FPDF_SetPrintModePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(ffi.Int)>>(
          'FPDF_SetPrintMode');
  late final _FPDF_SetPrintMode =
      _FPDF_SetPrintModePtr.asFunction<int Function(int)>();

  /// Function: FPDF_LoadDocument
  /// Open and load a PDF document.
  /// Parameters:
  /// file_path -  Path to the PDF file (including extension).
  /// password  -  A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// See comments below regarding the encoding.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// Loaded document can be closed by FPDF_CloseDocument().
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// The encoding for |file_path| is UTF-8.
  ///
  /// The encoding for |password| can be either UTF-8 or Latin-1. PDFs,
  /// depending on the security handler revision, will only accept one or
  /// the other encoding. If |password|'s encoding and the PDF's expected
  /// encoding do not match, FPDF_LoadDocument() will automatically
  /// convert |password| to the other encoding.
  FPDF_DOCUMENT FPDF_LoadDocument(
    FPDF_STRING file_path,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadDocument(
      file_path,
      password,
    );
  }

  late final _FPDF_LoadDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(
              FPDF_STRING, FPDF_BYTESTRING)>>('FPDF_LoadDocument');
  late final _FPDF_LoadDocument = _FPDF_LoadDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(FPDF_STRING, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadMemDocument
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadMemDocument(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadMemDocument(
      data_buf,
      size,
      password,
    );
  }

  late final _FPDF_LoadMemDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Int,
              FPDF_BYTESTRING)>>('FPDF_LoadMemDocument');
  late final _FPDF_LoadMemDocument = _FPDF_LoadMemDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Experimental API.
  /// Function: FPDF_LoadMemDocument64
  /// Open and load a PDF document from memory.
  /// Parameters:
  /// data_buf    -   Pointer to a buffer containing the PDF document.
  /// size        -   Number of bytes in the PDF document.
  /// password    -   A string used as the password for the PDF file.
  /// If no password is needed, empty or NULL can be used.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The memory buffer must remain valid when the document is open.
  /// The loaded document can be closed by FPDF_CloseDocument.
  /// If this function fails, you can use FPDF_GetLastError() to retrieve
  /// the reason why it failed.
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadMemDocument64(
    ffi.Pointer<ffi.Void> data_buf,
    int size,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadMemDocument64(
      data_buf,
      size,
      password,
    );
  }

  late final _FPDF_LoadMemDocument64Ptr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, ffi.Size,
              FPDF_BYTESTRING)>>('FPDF_LoadMemDocument64');
  late final _FPDF_LoadMemDocument64 = _FPDF_LoadMemDocument64Ptr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<ffi.Void>, int, FPDF_BYTESTRING)>();

  /// Function: FPDF_LoadCustomDocument
  /// Load PDF document from a custom access descriptor.
  /// Parameters:
  /// pFileAccess -   A structure for accessing the file.
  /// password    -   Optional password for decrypting the PDF file.
  /// Return value:
  /// A handle to the loaded document, or NULL on failure.
  /// Comments:
  /// The application must keep the file resources |pFileAccess| points to
  /// valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|
  /// itself does not need to outlive the FPDF_DOCUMENT.
  ///
  /// The loaded document can be closed with FPDF_CloseDocument().
  ///
  /// See the comments for FPDF_LoadDocument() regarding the encoding for
  /// |password|.
  /// Notes:
  /// If PDFium is built with the XFA module, the application should call
  /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
  /// fields defined in the fpdfformfill.h file.
  FPDF_DOCUMENT FPDF_LoadCustomDocument(
    ffi.Pointer<FPDF_FILEACCESS> pFileAccess,
    FPDF_BYTESTRING password,
  ) {
    return _FPDF_LoadCustomDocument(
      pFileAccess,
      password,
    );
  }

  late final _FPDF_LoadCustomDocumentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>,
              FPDF_BYTESTRING)>>('FPDF_LoadCustomDocument');
  late final _FPDF_LoadCustomDocument = _FPDF_LoadCustomDocumentPtr.asFunction<
      FPDF_DOCUMENT Function(ffi.Pointer<FPDF_FILEACCESS>, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetFileVersion
  /// Get the file version of the given PDF document.
  /// Parameters:
  /// doc         -   Handle to a document.
  /// fileVersion -   The PDF file version. File version: 14 for 1.4, 15
  /// for 1.5, ...
  /// Return value:
  /// True if succeeds, false otherwise.
  /// Comments:
  /// If the document was created by FPDF_CreateNewDocument,
  /// then this function will always fail.
  int FPDF_GetFileVersion(
    FPDF_DOCUMENT doc,
    ffi.Pointer<ffi.Int> fileVersion,
  ) {
    return _FPDF_GetFileVersion(
      doc,
      fileVersion,
    );
  }

  late final _FPDF_GetFileVersionPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT, ffi.Pointer<ffi.Int>)>>('FPDF_GetFileVersion');
  late final _FPDF_GetFileVersion = _FPDF_GetFileVersionPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDF_GetLastError
  /// Get last error code when a function fails.
  /// Parameters:
  /// None.
  /// Return value:
  /// A 32-bit integer indicating error code as defined above.
  /// Comments:
  /// If the previous SDK call succeeded, the return value of this
  /// function is not defined. This function only works in conjunction
  /// with APIs that mention FPDF_GetLastError() in their documentation.
  int FPDF_GetLastError() {
    return _FPDF_GetLastError();
  }

  late final _FPDF_GetLastErrorPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'FPDF_GetLastError');
  late final _FPDF_GetLastError =
      _FPDF_GetLastErrorPtr.asFunction<int Function()>();

  /// Experimental API.
  /// Function: FPDF_DocumentHasValidCrossReferenceTable
  /// Whether the document's cross reference table is valid or not.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// True if the PDF parser did not encounter problems parsing the cross
  /// reference table. False if the parser could not parse the cross
  /// reference table and the table had to be rebuild from other data
  /// within the document.
  /// Comments:
  /// The return value can change over time as the PDF parser evolves.
  int FPDF_DocumentHasValidCrossReferenceTable(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_DocumentHasValidCrossReferenceTable(
      document,
    );
  }

  late final _FPDF_DocumentHasValidCrossReferenceTablePtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'FPDF_DocumentHasValidCrossReferenceTable');
  late final _FPDF_DocumentHasValidCrossReferenceTable =
      _FPDF_DocumentHasValidCrossReferenceTablePtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetTrailerEnds
  /// Get the byte offsets of trailer ends.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// buffer      -   The address of a buffer that receives the
  /// byte offsets.
  /// length      -   The size, in ints, of |buffer|.
  /// Return value:
  /// Returns the number of ints in the buffer on success, 0 on error.
  ///
  /// |buffer| is an array of integers that describes the exact byte offsets of the
  /// trailer ends in the document. If |length| is less than the returned length,
  /// or |document| or |buffer| is NULL, |buffer| will not be modified.
  int FPDF_GetTrailerEnds(
    FPDF_DOCUMENT document,
    ffi.Pointer<ffi.UnsignedInt> buffer,
    int length,
  ) {
    return _FPDF_GetTrailerEnds(
      document,
      buffer,
      length,
    );
  }

  late final _FPDF_GetTrailerEndsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedLong)>>('FPDF_GetTrailerEnds');
  late final _FPDF_GetTrailerEnds = _FPDF_GetTrailerEndsPtr.asFunction<
      int Function(FPDF_DOCUMENT, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Function: FPDF_GetDocPermission
  /// Get file permission flags of the document.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// A 32-bit integer indicating permission flags. Please refer to the
  /// PDF Reference for detailed descriptions. If the document is not
  /// protected, 0xffffffff will be returned.
  int FPDF_GetDocPermissions(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetDocPermissions(
      document,
    );
  }

  late final _FPDF_GetDocPermissionsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(FPDF_DOCUMENT)>>(
          'FPDF_GetDocPermissions');
  late final _FPDF_GetDocPermissions =
      _FPDF_GetDocPermissionsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetSecurityHandlerRevision
  /// Get the revision for the security handler.
  /// Parameters:
  /// document    -   Handle to a document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// The security handler revision number. Please refer to the PDF
  /// Reference for a detailed description. If the document is not
  /// protected, -1 will be returned.
  int FPDF_GetSecurityHandlerRevision(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetSecurityHandlerRevision(
      document,
    );
  }

  late final _FPDF_GetSecurityHandlerRevisionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetSecurityHandlerRevision');
  late final _FPDF_GetSecurityHandlerRevision =
      _FPDF_GetSecurityHandlerRevisionPtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetPageCount
  /// Get total number of pages in the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// Return value:
  /// Total number of pages in the document.
  int FPDF_GetPageCount(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetPageCount(
      document,
    );
  }

  late final _FPDF_GetPageCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetPageCount');
  late final _FPDF_GetPageCount =
      _FPDF_GetPageCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_LoadPage
  /// Load a page inside the document.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument
  /// page_index  -   Index number of the page. 0 for the first page.
  /// Return value:
  /// A handle to the loaded page, or NULL if page load fails.
  /// Comments:
  /// The loaded page can be rendered to devices using FPDF_RenderPage.
  /// The loaded page can be closed using FPDF_ClosePage.
  FPDF_PAGE FPDF_LoadPage(
    FPDF_DOCUMENT document,
    int page_index,
  ) {
    return _FPDF_LoadPage(
      document,
      page_index,
    );
  }

  late final _FPDF_LoadPagePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGE Function(FPDF_DOCUMENT, ffi.Int)>>(
          'FPDF_LoadPage');
  late final _FPDF_LoadPage =
      _FPDF_LoadPagePtr.asFunction<FPDF_PAGE Function(FPDF_DOCUMENT, int)>();

  /// Experimental API
  /// Function: FPDF_GetPageWidthF
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  double FPDF_GetPageWidthF(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageWidthF(
      page,
    );
  }

  late final _FPDF_GetPageWidthFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'FPDF_GetPageWidthF');
  late final _FPDF_GetPageWidthF =
      _FPDF_GetPageWidthFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageWidth
  /// Get page width.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page width (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm).
  /// Note:
  /// Prefer FPDF_GetPageWidthF() above. This will be deprecated in the
  /// future.
  double FPDF_GetPageWidth(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageWidth(
      page,
    );
  }

  late final _FPDF_GetPageWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'FPDF_GetPageWidth');
  late final _FPDF_GetPageWidth =
      _FPDF_GetPageWidthPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API
  /// Function: FPDF_GetPageHeightF
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage().
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  double FPDF_GetPageHeightF(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageHeightF(
      page,
    );
  }

  late final _FPDF_GetPageHeightFPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_PAGE)>>(
          'FPDF_GetPageHeightF');
  late final _FPDF_GetPageHeightF =
      _FPDF_GetPageHeightFPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Function: FPDF_GetPageHeight
  /// Get page height.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// Return value:
  /// Page height (excluding non-displayable area) measured in points.
  /// One point is 1/72 inch (around 0.3528 mm)
  /// Note:
  /// Prefer FPDF_GetPageHeightF() above. This will be deprecated in the
  /// future.
  double FPDF_GetPageHeight(
    FPDF_PAGE page,
  ) {
    return _FPDF_GetPageHeight(
      page,
    );
  }

  late final _FPDF_GetPageHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_PAGE)>>(
          'FPDF_GetPageHeight');
  late final _FPDF_GetPageHeight =
      _FPDF_GetPageHeightPtr.asFunction<double Function(FPDF_PAGE)>();

  /// Experimental API.
  /// Function: FPDF_GetPageBoundingBox
  /// Get the bounding box of the page. This is the intersection between
  /// its media box and its crop box.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// rect        -   Pointer to a rect to receive the page bounding box.
  /// On an error, |rect| won't be filled.
  /// Return value:
  /// True for success.
  int FPDF_GetPageBoundingBox(
    FPDF_PAGE page,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _FPDF_GetPageBoundingBox(
      page,
      rect,
    );
  }

  late final _FPDF_GetPageBoundingBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE, ffi.Pointer<FS_RECTF>)>>('FPDF_GetPageBoundingBox');
  late final _FPDF_GetPageBoundingBox = _FPDF_GetPageBoundingBoxPtr.asFunction<
      int Function(FPDF_PAGE, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Function: FPDF_GetPageSizeByIndexF
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument().
  /// page_index  -   Page index, zero for the first page.
  /// size        -   Pointer to a FS_SIZEF to receive the page size.
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  int FPDF_GetPageSizeByIndexF(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<FS_SIZEF> size,
  ) {
    return _FPDF_GetPageSizeByIndexF(
      document,
      page_index,
      size,
    );
  }

  late final _FPDF_GetPageSizeByIndexFPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_DOCUMENT, ffi.Int,
              ffi.Pointer<FS_SIZEF>)>>('FPDF_GetPageSizeByIndexF');
  late final _FPDF_GetPageSizeByIndexF = _FPDF_GetPageSizeByIndexFPtr
      .asFunction<int Function(FPDF_DOCUMENT, int, ffi.Pointer<FS_SIZEF>)>();

  /// Function: FPDF_GetPageSizeByIndex
  /// Get the size of the page at the given index.
  /// Parameters:
  /// document    -   Handle to document. Returned by FPDF_LoadDocument.
  /// page_index  -   Page index, zero for the first page.
  /// width       -   Pointer to a double to receive the page width
  /// (in points).
  /// height      -   Pointer to a double to receive the page height
  /// (in points).
  /// Return value:
  /// Non-zero for success. 0 for error (document or page not found).
  /// Note:
  /// Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in
  /// the future.
  int FPDF_GetPageSizeByIndex(
    FPDF_DOCUMENT document,
    int page_index,
    ffi.Pointer<ffi.Double> width,
    ffi.Pointer<ffi.Double> height,
  ) {
    return _FPDF_GetPageSizeByIndex(
      document,
      page_index,
      width,
      height,
    );
  }

  late final _FPDF_GetPageSizeByIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDF_GetPageSizeByIndex');
  late final _FPDF_GetPageSizeByIndex = _FPDF_GetPageSizeByIndexPtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_RenderPage
  /// Render contents of a page to a device (screen, bitmap, or printer).
  /// This function is only supported on Windows.
  /// Parameters:
  /// dc          -   Handle to the device context.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// flags       -   0 for normal display, or combination of flags
  /// defined above.
  /// Return value:
  /// None.
  void FPDF_RenderPage(
    HDC dc,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _FPDF_RenderPage(
      dc,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _FPDF_RenderPagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(HDC, FPDF_PAGE, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int)>>('FPDF_RenderPage');
  late final _FPDF_RenderPage = _FPDF_RenderPagePtr.asFunction<
      void Function(HDC, FPDF_PAGE, int, int, int, int, int, int)>();

  /// Function: FPDF_RenderPageBitmap
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved from an image
  /// object by FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage
  /// start_x     -   Left pixel position of the display area in
  /// bitmap coordinates.
  /// start_y     -   Top pixel position of the display area in bitmap
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None.
  void FPDF_RenderPageBitmap(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags,
  ) {
    return _FPDF_RenderPageBitmap(
      bitmap,
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      flags,
    );
  }

  late final _FPDF_RenderPageBitmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int)>>('FPDF_RenderPageBitmap');
  late final _FPDF_RenderPageBitmap = _FPDF_RenderPageBitmapPtr.asFunction<
      void Function(FPDF_BITMAP, FPDF_PAGE, int, int, int, int, int, int)>();

  /// Function: FPDF_RenderPageBitmapWithMatrix
  /// Render contents of a page to a device independent bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the device independent bitmap (as the
  /// output buffer). The bitmap handle can be created
  /// by FPDFBitmap_Create or retrieved by
  /// FPDFImageObj_GetBitmap.
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// matrix      -   The transform matrix, which must be invertible.
  /// See PDF Reference 1.7, 4.2.2 Common Transformations.
  /// clipping    -   The rect to clip to in device coords.
  /// flags       -   0 for normal display, or combination of the Page
  /// Rendering flags defined above. With the FPDF_ANNOT
  /// flag, it renders all annotations that do not require
  /// user-interaction, which are all annotations except
  /// widget and popup annotations.
  /// Return value:
  /// None. Note that behavior is undefined if det of |matrix| is 0.
  void FPDF_RenderPageBitmapWithMatrix(
    FPDF_BITMAP bitmap,
    FPDF_PAGE page,
    ffi.Pointer<FS_MATRIX> matrix,
    ffi.Pointer<FS_RECTF> clipping,
    int flags,
  ) {
    return _FPDF_RenderPageBitmapWithMatrix(
      bitmap,
      page,
      matrix,
      clipping,
      flags,
    );
  }

  late final _FPDF_RenderPageBitmapWithMatrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              FPDF_BITMAP,
              FPDF_PAGE,
              ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>,
              ffi.Int)>>('FPDF_RenderPageBitmapWithMatrix');
  late final _FPDF_RenderPageBitmapWithMatrix =
      _FPDF_RenderPageBitmapWithMatrixPtr.asFunction<
          void Function(FPDF_BITMAP, FPDF_PAGE, ffi.Pointer<FS_MATRIX>,
              ffi.Pointer<FS_RECTF>, int)>();

  /// Function: FPDF_ClosePage
  /// Close a loaded PDF page.
  /// Parameters:
  /// page        -   Handle to the loaded page.
  /// Return value:
  /// None.
  void FPDF_ClosePage(
    FPDF_PAGE page,
  ) {
    return _FPDF_ClosePage(
      page,
    );
  }

  late final _FPDF_ClosePagePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGE)>>(
          'FPDF_ClosePage');
  late final _FPDF_ClosePage =
      _FPDF_ClosePagePtr.asFunction<void Function(FPDF_PAGE)>();

  /// Function: FPDF_CloseDocument
  /// Close a loaded PDF document.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  void FPDF_CloseDocument(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_CloseDocument(
      document,
    );
  }

  late final _FPDF_CloseDocumentPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_DOCUMENT)>>(
          'FPDF_CloseDocument');
  late final _FPDF_CloseDocument =
      _FPDF_CloseDocumentPtr.asFunction<void Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_DeviceToPage
  /// Convert the screen coordinates of a point to page coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// device_x    -   X value in device coordinates to be converted.
  /// device_y    -   Y value in device coordinates to be converted.
  /// page_x      -   A pointer to a double receiving the converted X
  /// value in page coordinates.
  /// page_y      -   A pointer to a double receiving the converted Y
  /// value in page coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |page_x| and |page_y|
  /// successfully receives the converted coordinates.
  /// Comments:
  /// The page coordinate system has its origin at the left-bottom corner
  /// of the page, with the X-axis on the bottom going to the right, and
  /// the Y-axis on the left side going up.
  ///
  /// NOTE: this coordinate system can be altered when you zoom, scroll,
  /// or rotate a page, however, a point on the page should always have
  /// the same coordinate values in the page coordinate system.
  ///
  /// The device coordinate system is device dependent. For screen device,
  /// its origin is at the left-top corner of the window. However this
  /// origin can be altered by the Windows coordinate transformation
  /// utilities.
  ///
  /// You must make sure the start_x, start_y, size_x, size_y
  /// and rotate parameters have exactly same values as you used in
  /// the FPDF_RenderPage() function call.
  int FPDF_DeviceToPage(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int device_x,
    int device_y,
    ffi.Pointer<ffi.Double> page_x,
    ffi.Pointer<ffi.Double> page_y,
  ) {
    return _FPDF_DeviceToPage(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      device_x,
      device_y,
      page_x,
      page_y,
    );
  }

  late final _FPDF_DeviceToPagePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDF_DeviceToPage');
  late final _FPDF_DeviceToPage = _FPDF_DeviceToPagePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, int, int,
          ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>)>();

  /// Function: FPDF_PageToDevice
  /// Convert the page coordinates of a point to screen coordinates.
  /// Parameters:
  /// page        -   Handle to the page. Returned by FPDF_LoadPage.
  /// start_x     -   Left pixel position of the display area in
  /// device coordinates.
  /// start_y     -   Top pixel position of the display area in device
  /// coordinates.
  /// size_x      -   Horizontal size (in pixels) for displaying the page.
  /// size_y      -   Vertical size (in pixels) for displaying the page.
  /// rotate      -   Page orientation:
  /// 0 (normal)
  /// 1 (rotated 90 degrees clockwise)
  /// 2 (rotated 180 degrees)
  /// 3 (rotated 90 degrees counter-clockwise)
  /// page_x      -   X value in page coordinates.
  /// page_y      -   Y value in page coordinate.
  /// device_x    -   A pointer to an integer receiving the result X
  /// value in device coordinates.
  /// device_y    -   A pointer to an integer receiving the result Y
  /// value in device coordinates.
  /// Return value:
  /// Returns true if the conversion succeeds, and |device_x| and
  /// |device_y| successfully receives the converted coordinates.
  /// Comments:
  /// See comments for FPDF_DeviceToPage().
  int FPDF_PageToDevice(
    FPDF_PAGE page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    double page_x,
    double page_y,
    ffi.Pointer<ffi.Int> device_x,
    ffi.Pointer<ffi.Int> device_y,
  ) {
    return _FPDF_PageToDevice(
      page,
      start_x,
      start_y,
      size_x,
      size_y,
      rotate,
      page_x,
      page_y,
      device_x,
      device_y,
    );
  }

  late final _FPDF_PageToDevicePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGE,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('FPDF_PageToDevice');
  late final _FPDF_PageToDevice = _FPDF_PageToDevicePtr.asFunction<
      int Function(FPDF_PAGE, int, int, int, int, int, double, double,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDFBitmap_Create
  /// Create a device independent bitmap (FXDIB).
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// alpha       -   A flag indicating whether the alpha channel is used.
  /// Non-zero for using alpha, zero for not using.
  /// Return value:
  /// The created bitmap handle, or NULL if a parameter error or out of
  /// memory.
  /// Comments:
  /// The bitmap always uses 4 bytes per pixel. The first byte is always
  /// double word aligned.
  ///
  /// The byte order is BGRx (the last byte unused if no alpha channel) or
  /// BGRA.
  ///
  /// The pixels in a horizontal line are stored side by side, with the
  /// left most pixel stored first (with lower memory address).
  /// Each line uses width * 4 bytes.
  ///
  /// Lines are stored one after another, with the top most line stored
  /// first. There is no gap between adjacent lines.
  ///
  /// This function allocates enough memory for holding all pixels in the
  /// bitmap, but it doesn't initialize the buffer. Applications can use
  /// FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS
  /// allows it, this function can allocate up to 4 GB of memory.
  FPDF_BITMAP FPDFBitmap_Create(
    int width,
    int height,
    int alpha,
  ) {
    return _FPDFBitmap_Create(
      width,
      height,
      alpha,
    );
  }

  late final _FPDFBitmap_CreatePtr = _lookup<
          ffi.NativeFunction<FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int)>>(
      'FPDFBitmap_Create');
  late final _FPDFBitmap_Create =
      _FPDFBitmap_CreatePtr.asFunction<FPDF_BITMAP Function(int, int, int)>();

  /// Function: FPDFBitmap_CreateEx
  /// Create a device independent bitmap (FXDIB)
  /// Parameters:
  /// width       -   The number of pixels in width for the bitmap.
  /// Must be greater than 0.
  /// height      -   The number of pixels in height for the bitmap.
  /// Must be greater than 0.
  /// format      -   A number indicating for bitmap format, as defined
  /// above.
  /// first_scan  -   A pointer to the first byte of the first line if
  /// using an external buffer. If this parameter is NULL,
  /// then a new buffer will be created.
  /// stride      -   Number of bytes for each scan line. The value must
  /// be 0 or greater. When the value is 0,
  /// FPDFBitmap_CreateEx() will automatically calculate
  /// the appropriate value using |width| and |format|.
  /// When using an external buffer, it is recommended for
  /// the caller to pass in the value.
  /// When not using an external buffer, it is recommended
  /// for the caller to pass in 0.
  /// Return value:
  /// The bitmap handle, or NULL if parameter error or out of memory.
  /// Comments:
  /// Similar to FPDFBitmap_Create function, but allows for more formats
  /// and an external buffer is supported. The bitmap created by this
  /// function can be used in any place that a FPDF_BITMAP handle is
  /// required.
  ///
  /// If an external buffer is used, then the caller should destroy the
  /// buffer. FPDFBitmap_Destroy() will not destroy the buffer.
  ///
  /// It is recommended to use FPDFBitmap_GetStride() to get the stride
  /// value.
  FPDF_BITMAP FPDFBitmap_CreateEx(
    int width,
    int height,
    int format,
    ffi.Pointer<ffi.Void> first_scan,
    int stride,
  ) {
    return _FPDFBitmap_CreateEx(
      width,
      height,
      format,
      first_scan,
      stride,
    );
  }

  late final _FPDFBitmap_CreateExPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BITMAP Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('FPDFBitmap_CreateEx');
  late final _FPDFBitmap_CreateEx = _FPDFBitmap_CreateExPtr.asFunction<
      FPDF_BITMAP Function(int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// Function: FPDFBitmap_GetFormat
  /// Get the format of the bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The format of the bitmap.
  /// Comments:
  /// Only formats supported by FPDFBitmap_CreateEx are supported by this
  /// function; see the list of such formats above.
  int FPDFBitmap_GetFormat(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetFormat(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetFormatPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetFormat');
  late final _FPDFBitmap_GetFormat =
      _FPDFBitmap_GetFormatPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_FillRect
  /// Fill a rectangle in a bitmap.
  /// Parameters:
  /// bitmap      -   The handle to the bitmap. Returned by
  /// FPDFBitmap_Create.
  /// left        -   The left position. Starting from 0 at the
  /// left-most pixel.
  /// top         -   The top position. Starting from 0 at the
  /// top-most line.
  /// width       -   Width in pixels to be filled.
  /// height      -   Height in pixels to be filled.
  /// color       -   A 32-bit value specifing the color, in 8888 ARGB
  /// format.
  /// Return value:
  /// None.
  /// Comments:
  /// This function sets the color and (optionally) alpha value in the
  /// specified region of the bitmap.
  ///
  /// NOTE: If the alpha channel is used, this function does NOT
  /// composite the background with the source color, instead the
  /// background will be replaced by the source color and the alpha.
  ///
  /// If the alpha channel is not used, the alpha parameter is ignored.
  void FPDFBitmap_FillRect(
    FPDF_BITMAP bitmap,
    int left,
    int top,
    int width,
    int height,
    int color,
  ) {
    return _FPDFBitmap_FillRect(
      bitmap,
      left,
      top,
      width,
      height,
      color,
    );
  }

  late final _FPDFBitmap_FillRectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(FPDF_BITMAP, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              FPDF_DWORD)>>('FPDFBitmap_FillRect');
  late final _FPDFBitmap_FillRect = _FPDFBitmap_FillRectPtr.asFunction<
      void Function(FPDF_BITMAP, int, int, int, int, int)>();

  /// Function: FPDFBitmap_GetBuffer
  /// Get data buffer of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The pointer to the first byte of the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel
  ///
  /// Applications can use this function to get the bitmap buffer pointer,
  /// then manipulate any color and/or alpha values for any pixels in the
  /// bitmap.
  ///
  /// Use FPDFBitmap_GetFormat() to find out the format of the data.
  ffi.Pointer<ffi.Void> FPDFBitmap_GetBuffer(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetBuffer(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetBuffer');
  late final _FPDFBitmap_GetBuffer = _FPDFBitmap_GetBufferPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetWidth
  /// Get width of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The width of the bitmap in pixels.
  int FPDFBitmap_GetWidth(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetWidth(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetWidth');
  late final _FPDFBitmap_GetWidth =
      _FPDFBitmap_GetWidthPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetHeight
  /// Get height of a bitmap.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The height of the bitmap in pixels.
  int FPDFBitmap_GetHeight(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetHeight(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetHeight');
  late final _FPDFBitmap_GetHeight =
      _FPDFBitmap_GetHeightPtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_GetStride
  /// Get number of bytes for each line in the bitmap buffer.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// The number of bytes for each line in the bitmap buffer.
  /// Comments:
  /// The stride may be more than width * number of bytes per pixel.
  int FPDFBitmap_GetStride(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_GetStride(
      bitmap,
    );
  }

  late final _FPDFBitmap_GetStridePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_BITMAP)>>(
          'FPDFBitmap_GetStride');
  late final _FPDFBitmap_GetStride =
      _FPDFBitmap_GetStridePtr.asFunction<int Function(FPDF_BITMAP)>();

  /// Function: FPDFBitmap_Destroy
  /// Destroy a bitmap and release all related buffers.
  /// Parameters:
  /// bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create
  /// or FPDFImageObj_GetBitmap.
  /// Return value:
  /// None.
  /// Comments:
  /// This function will not destroy any external buffers provided when
  /// the bitmap was created.
  void FPDFBitmap_Destroy(
    FPDF_BITMAP bitmap,
  ) {
    return _FPDFBitmap_Destroy(
      bitmap,
    );
  }

  late final _FPDFBitmap_DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_BITMAP)>>(
          'FPDFBitmap_Destroy');
  late final _FPDFBitmap_Destroy =
      _FPDFBitmap_DestroyPtr.asFunction<void Function(FPDF_BITMAP)>();

  /// Function: FPDF_VIEWERREF_GetPrintScaling
  /// Whether the PDF document prefers to be scaled or not.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// None.
  int FPDF_VIEWERREF_GetPrintScaling(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetPrintScaling(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintScalingPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetPrintScaling');
  late final _FPDF_VIEWERREF_GetPrintScaling =
      _FPDF_VIEWERREF_GetPrintScalingPtr.asFunction<
          int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetNumCopies
  /// Returns the number of copies to be printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The number of copies to be printed.
  int FPDF_VIEWERREF_GetNumCopies(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetNumCopies(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetNumCopiesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetNumCopies');
  late final _FPDF_VIEWERREF_GetNumCopies =
      _FPDF_VIEWERREF_GetNumCopiesPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetPrintPageRange
  /// Page numbers to initialize print dialog box when file is printed.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The print page range to be used for printing.
  FPDF_PAGERANGE FPDF_VIEWERREF_GetPrintPageRange(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRange(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangePtr =
      _lookup<ffi.NativeFunction<FPDF_PAGERANGE Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetPrintPageRange');
  late final _FPDF_VIEWERREF_GetPrintPageRange =
      _FPDF_VIEWERREF_GetPrintPageRangePtr.asFunction<
          FPDF_PAGERANGE Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeCount
  /// Returns the number of elements in a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// Return value:
  /// The number of elements in the page range. Returns 0 on error.
  int FPDF_VIEWERREF_GetPrintPageRangeCount(
    FPDF_PAGERANGE pagerange,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRangeCount(
      pagerange,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangeCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(FPDF_PAGERANGE)>>(
          'FPDF_VIEWERREF_GetPrintPageRangeCount');
  late final _FPDF_VIEWERREF_GetPrintPageRangeCount =
      _FPDF_VIEWERREF_GetPrintPageRangeCountPtr.asFunction<
          int Function(FPDF_PAGERANGE)>();

  /// Experimental API.
  /// Function: FPDF_VIEWERREF_GetPrintPageRangeElement
  /// Returns an element from a FPDF_PAGERANGE.
  /// Parameters:
  /// pagerange   -   Handle to the page range.
  /// index       -   Index of the element.
  /// Return value:
  /// The value of the element in the page range at a given index.
  /// Returns -1 on error.
  int FPDF_VIEWERREF_GetPrintPageRangeElement(
    FPDF_PAGERANGE pagerange,
    int index,
  ) {
    return _FPDF_VIEWERREF_GetPrintPageRangeElement(
      pagerange,
      index,
    );
  }

  late final _FPDF_VIEWERREF_GetPrintPageRangeElementPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGERANGE, ffi.Size)>>(
          'FPDF_VIEWERREF_GetPrintPageRangeElement');
  late final _FPDF_VIEWERREF_GetPrintPageRangeElement =
      _FPDF_VIEWERREF_GetPrintPageRangeElementPtr.asFunction<
          int Function(FPDF_PAGERANGE, int)>();

  /// Function: FPDF_VIEWERREF_GetDuplex
  /// Returns the paper handling option to be used when printing from
  /// the print dialog.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// Return value:
  /// The paper handling option to be used when printing.
  int FPDF_VIEWERREF_GetDuplex(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_VIEWERREF_GetDuplex(
      document,
    );
  }

  late final _FPDF_VIEWERREF_GetDuplexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(FPDF_DOCUMENT)>>(
          'FPDF_VIEWERREF_GetDuplex');
  late final _FPDF_VIEWERREF_GetDuplex =
      _FPDF_VIEWERREF_GetDuplexPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_VIEWERREF_GetName
  /// Gets the contents for a viewer ref, with a given key. The value must
  /// be of type "name".
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// key         -   Name of the key in the viewer pref dictionary,
  /// encoded in UTF-8.
  /// buffer      -   A string to write the contents of the key to.
  /// length      -   Length of the buffer.
  /// Return value:
  /// The number of bytes in the contents, including the NULL terminator.
  /// Thus if the return value is 0, then that indicates an error, such
  /// as when |document| is invalid or |buffer| is NULL. If |length| is
  /// less than the returned length, or |buffer| is NULL, |buffer| will
  /// not be modified.
  int FPDF_VIEWERREF_GetName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING key,
    ffi.Pointer<ffi.Char> buffer,
    int length,
  ) {
    return _FPDF_VIEWERREF_GetName(
      document,
      key,
      buffer,
      length,
    );
  }

  late final _FPDF_VIEWERREF_GetNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              FPDF_BYTESTRING,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedLong)>>('FPDF_VIEWERREF_GetName');
  late final _FPDF_VIEWERREF_GetName = _FPDF_VIEWERREF_GetNamePtr.asFunction<
      int Function(
          FPDF_DOCUMENT, FPDF_BYTESTRING, ffi.Pointer<ffi.Char>, int)>();

  /// Function: FPDF_CountNamedDests
  /// Get the count of named destinations in the PDF document.
  /// Parameters:
  /// document    -   Handle to a document
  /// Return value:
  /// The count of named destinations.
  int FPDF_CountNamedDests(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_CountNamedDests(
      document,
    );
  }

  late final _FPDF_CountNamedDestsPtr =
      _lookup<ffi.NativeFunction<FPDF_DWORD Function(FPDF_DOCUMENT)>>(
          'FPDF_CountNamedDests');
  late final _FPDF_CountNamedDests =
      _FPDF_CountNamedDestsPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Function: FPDF_GetNamedDestByName
  /// Get a the destination handle for the given name.
  /// Parameters:
  /// document    -   Handle to the loaded document.
  /// name        -   The name of a destination.
  /// Return value:
  /// The handle to the destination.
  FPDF_DEST FPDF_GetNamedDestByName(
    FPDF_DOCUMENT document,
    FPDF_BYTESTRING name,
  ) {
    return _FPDF_GetNamedDestByName(
      document,
      name,
    );
  }

  late final _FPDF_GetNamedDestByNamePtr = _lookup<
      ffi.NativeFunction<
          FPDF_DEST Function(
              FPDF_DOCUMENT, FPDF_BYTESTRING)>>('FPDF_GetNamedDestByName');
  late final _FPDF_GetNamedDestByName = _FPDF_GetNamedDestByNamePtr.asFunction<
      FPDF_DEST Function(FPDF_DOCUMENT, FPDF_BYTESTRING)>();

  /// Function: FPDF_GetNamedDest
  /// Get the named destination by index.
  /// Parameters:
  /// document        -   Handle to a document
  /// index           -   The index of a named destination.
  /// buffer          -   The buffer to store the destination name,
  /// used as wchar_t*.
  /// buflen [in/out] -   Size of the buffer in bytes on input,
  /// length of the result in bytes on output
  /// or -1 if the buffer is too small.
  /// Return value:
  /// The destination handle for a given index, or NULL if there is no
  /// named destination corresponding to |index|.
  /// Comments:
  /// Call this function twice to get the name of the named destination:
  /// 1) First time pass in |buffer| as NULL and get buflen.
  /// 2) Second time pass in allocated |buffer| and buflen to retrieve
  /// |buffer|, which should be used as wchar_t*.
  ///
  /// If buflen is not sufficiently large, it will be set to -1 upon
  /// return.
  FPDF_DEST FPDF_GetNamedDest(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    ffi.Pointer<ffi.Long> buflen,
  ) {
    return _FPDF_GetNamedDest(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _FPDF_GetNamedDestPtr = _lookup<
      ffi.NativeFunction<
          FPDF_DEST Function(FPDF_DOCUMENT, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Long>)>>('FPDF_GetNamedDest');
  late final _FPDF_GetNamedDest = _FPDF_GetNamedDestPtr.asFunction<
      FPDF_DEST Function(
          FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Long>)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketCount
  /// Get the number of valid packets in the XFA entry.
  /// Parameters:
  /// document - Handle to the document.
  /// Return value:
  /// The number of valid packets, or -1 on error.
  int FPDF_GetXFAPacketCount(
    FPDF_DOCUMENT document,
  ) {
    return _FPDF_GetXFAPacketCount(
      document,
    );
  }

  late final _FPDF_GetXFAPacketCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_DOCUMENT)>>(
          'FPDF_GetXFAPacketCount');
  late final _FPDF_GetXFAPacketCount =
      _FPDF_GetXFAPacketCountPtr.asFunction<int Function(FPDF_DOCUMENT)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketName
  /// Get the name of a packet in the XFA array.
  /// Parameters:
  /// document - Handle to the document.
  /// index    - Index number of the packet. 0 for the first packet.
  /// buffer   - Buffer for holding the name of the XFA packet.
  /// buflen   - Length of |buffer| in bytes.
  /// Return value:
  /// The length of the packet name in bytes, or 0 on error.
  ///
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount().
  /// |buffer| is only modified if it is non-NULL and |buflen| is greater than or
  /// equal to the length of the packet name. The packet name includes a
  /// terminating NUL character. |buffer| is unmodified on error.
  int FPDF_GetXFAPacketName(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
  ) {
    return _FPDF_GetXFAPacketName(
      document,
      index,
      buffer,
      buflen,
    );
  }

  late final _FPDF_GetXFAPacketNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong)>>('FPDF_GetXFAPacketName');
  late final _FPDF_GetXFAPacketName = _FPDF_GetXFAPacketNamePtr.asFunction<
      int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int)>();

  /// Experimental API.
  /// Function: FPDF_GetXFAPacketContent
  /// Get the content of a packet in the XFA array.
  /// Parameters:
  /// document   - Handle to the document.
  /// index      - Index number of the packet. 0 for the first packet.
  /// buffer     - Buffer for holding the content of the XFA packet.
  /// buflen     - Length of |buffer| in bytes.
  /// out_buflen - Pointer to the variable that will receive the minimum
  /// buffer size needed to contain the content of the XFA
  /// packet.
  /// Return value:
  /// Whether the operation succeeded or not.
  ///
  /// |document| must be valid and |index| must be in the range [0, N), where N is
  /// the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be
  /// NULL. When the aforementioned arguments are valid, the operation succeeds,
  /// and |out_buflen| receives the content size. |buffer| is only modified if
  /// |buffer| is non-null and long enough to contain the content. Callers must
  /// check both the return value and the input |buflen| is no less than the
  /// returned |out_buflen| before using the data in |buffer|.
  int FPDF_GetXFAPacketContent(
    FPDF_DOCUMENT document,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.UnsignedLong> out_buflen,
  ) {
    return _FPDF_GetXFAPacketContent(
      document,
      index,
      buffer,
      buflen,
      out_buflen,
    );
  }

  late final _FPDF_GetXFAPacketContentPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_DOCUMENT,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedLong>)>>('FPDF_GetXFAPacketContent');
  late final _FPDF_GetXFAPacketContent =
      _FPDF_GetXFAPacketContentPtr.asFunction<
          int Function(FPDF_DOCUMENT, int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.UnsignedLong>)>();

  /// Function: FPDFText_LoadPage
  /// Prepare information about all characters in a page.
  /// Parameters:
  /// page    -   Handle to the page. Returned by FPDF_LoadPage function
  /// (in FPDFVIEW module).
  /// Return value:
  /// A handle to the text page information structure.
  /// NULL if something goes wrong.
  /// Comments:
  /// Application must call FPDFText_ClosePage to release the text page
  /// information.
  FPDF_TEXTPAGE FPDFText_LoadPage(
    FPDF_PAGE page,
  ) {
    return _FPDFText_LoadPage(
      page,
    );
  }

  late final _FPDFText_LoadPagePtr =
      _lookup<ffi.NativeFunction<FPDF_TEXTPAGE Function(FPDF_PAGE)>>(
          'FPDFText_LoadPage');
  late final _FPDFText_LoadPage =
      _FPDFText_LoadPagePtr.asFunction<FPDF_TEXTPAGE Function(FPDF_PAGE)>();

  /// Function: FPDFText_ClosePage
  /// Release all resources allocated for a text page information
  /// structure.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return Value:
  /// None.
  void FPDFText_ClosePage(
    FPDF_TEXTPAGE text_page,
  ) {
    return _FPDFText_ClosePage(
      text_page,
    );
  }

  late final _FPDFText_ClosePagePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_TEXTPAGE)>>(
          'FPDFText_ClosePage');
  late final _FPDFText_ClosePage =
      _FPDFText_ClosePagePtr.asFunction<void Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFText_CountChars
  /// Get number of characters in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return value:
  /// Number of characters in the page. Return -1 for error.
  /// Generated characters, like additional space characters, new line
  /// characters, are also counted.
  /// Comments:
  /// Characters in a page form a "stream", inside the stream, each
  /// character has an index.
  /// We will use the index parameters in many of FPDFTEXT functions. The
  /// first character in the page
  /// has an index value of zero.
  int FPDFText_CountChars(
    FPDF_TEXTPAGE text_page,
  ) {
    return _FPDFText_CountChars(
      text_page,
    );
  }

  late final _FPDFText_CountCharsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE)>>(
          'FPDFText_CountChars');
  late final _FPDFText_CountChars =
      _FPDFText_CountCharsPtr.asFunction<int Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFText_GetUnicode
  /// Get Unicode of a character in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// The Unicode of the particular character.
  /// If a character is not encoded in Unicode and Foxit engine can't
  /// convert to Unicode,
  /// the return value will be zero.
  int FPDFText_GetUnicode(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_GetUnicode(
      text_page,
      index,
    );
  }

  late final _FPDFText_GetUnicodePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(FPDF_TEXTPAGE, ffi.Int)>>(
      'FPDFText_GetUnicode');
  late final _FPDFText_GetUnicode =
      _FPDFText_GetUnicodePtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_IsGenerated
  /// Get if a character in a page is generated by PDFium.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// 1 if the character is generated by PDFium.
  /// 0 if the character is not generated by PDFium.
  /// -1 if there was an error.
  int FPDFText_IsGenerated(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_IsGenerated(
      text_page,
      index,
    );
  }

  late final _FPDFText_IsGeneratedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_IsGenerated');
  late final _FPDFText_IsGenerated =
      _FPDFText_IsGeneratedPtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_HasUnicodeMapError
  /// Get if a character in a page has an invalid unicode mapping.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// 1 if the character has an invalid unicode mapping.
  /// 0 if the character has no known unicode mapping issues.
  /// -1 if there was an error.
  int FPDFText_HasUnicodeMapError(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_HasUnicodeMapError(
      text_page,
      index,
    );
  }

  late final _FPDFText_HasUnicodeMapErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_HasUnicodeMapError');
  late final _FPDFText_HasUnicodeMapError = _FPDFText_HasUnicodeMapErrorPtr
      .asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Function: FPDFText_GetFontSize
  /// Get the font size of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// The font size of the particular character, measured in points (about
  /// 1/72 inch). This is the typographic size of the font (so called
  /// "em size").
  double FPDFText_GetFontSize(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_GetFontSize(
      text_page,
      index,
    );
  }

  late final _FPDFText_GetFontSizePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_GetFontSize');
  late final _FPDFText_GetFontSize = _FPDFText_GetFontSizePtr.asFunction<
      double Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetFontInfo
  /// Get the font name and flags of a particular character.
  /// Parameters:
  /// text_page - Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index     - Zero-based index of the character.
  /// buffer    - A buffer receiving the font name.
  /// buflen    - The length of |buffer| in bytes.
  /// flags     - Optional pointer to an int receiving the font flags.
  /// These flags should be interpreted per PDF spec 1.7
  /// Section 5.7.1 Font Descriptor Flags.
  /// Return value:
  /// On success, return the length of the font name, including the
  /// trailing NUL character, in bytes. If this length is less than or
  /// equal to |length|, |buffer| is set to the font name, |flags| is
  /// set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on
  /// failure.
  int FPDFText_GetFontInfo(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Void> buffer,
    int buflen,
    ffi.Pointer<ffi.Int> flags,
  ) {
    return _FPDFText_GetFontInfo(
      text_page,
      index,
      buffer,
      buflen,
      flags,
    );
  }

  late final _FPDFText_GetFontInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Int>)>>('FPDFText_GetFontInfo');
  late final _FPDFText_GetFontInfo = _FPDFText_GetFontInfoPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<ffi.Int>)>();

  /// Experimental API.
  /// Function: FPDFText_GetFontWeight
  /// Get the font weight of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return value:
  /// On success, return the font weight of the particular character. If
  /// |text_page| is invalid, if |index| is out of bounds, or if the
  /// character's text object is undefined, return -1.
  int FPDFText_GetFontWeight(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_GetFontWeight(
      text_page,
      index,
    );
  }

  late final _FPDFText_GetFontWeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_GetFontWeight');
  late final _FPDFText_GetFontWeight =
      _FPDFText_GetFontWeightPtr.asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetTextRenderMode
  /// Get text rendering mode of character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return Value:
  /// On success, return the render mode value. A valid value is of type
  /// FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out
  /// of bounds, or if the text object is undefined, then return
  /// FPDF_TEXTRENDERMODE_UNKNOWN.
  int FPDFText_GetTextRenderMode(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_GetTextRenderMode(
      text_page,
      index,
    );
  }

  late final _FPDFText_GetTextRenderModePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_GetTextRenderMode');
  late final _FPDFText_GetTextRenderMode = _FPDFText_GetTextRenderModePtr
      .asFunction<int Function(FPDF_TEXTPAGE, int)>();

  /// Experimental API.
  /// Function: FPDFText_GetFillColor
  /// Get the fill color of a particular character.
  /// Parameters:
  /// text_page      -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index          -   Zero-based index of the character.
  /// R              -   Pointer to an unsigned int number receiving the
  /// red value of the fill color.
  /// G              -   Pointer to an unsigned int number receiving the
  /// green value of the fill color.
  /// B              -   Pointer to an unsigned int number receiving the
  /// blue value of the fill color.
  /// A              -   Pointer to an unsigned int number receiving the
  /// alpha value of the fill color.
  /// Return value:
  /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
  /// unchanged.
  int FPDFText_GetFillColor(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _FPDFText_GetFillColor(
      text_page,
      index,
      R,
      G,
      B,
      A,
    );
  }

  late final _FPDFText_GetFillColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('FPDFText_GetFillColor');
  late final _FPDFText_GetFillColor = _FPDFText_GetFillColorPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Function: FPDFText_GetStrokeColor
  /// Get the stroke color of a particular character.
  /// Parameters:
  /// text_page      -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index          -   Zero-based index of the character.
  /// R              -   Pointer to an unsigned int number receiving the
  /// red value of the stroke color.
  /// G              -   Pointer to an unsigned int number receiving the
  /// green value of the stroke color.
  /// B              -   Pointer to an unsigned int number receiving the
  /// blue value of the stroke color.
  /// A              -   Pointer to an unsigned int number receiving the
  /// alpha value of the stroke color.
  /// Return value:
  /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
  /// unchanged.
  int FPDFText_GetStrokeColor(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.UnsignedInt> R,
    ffi.Pointer<ffi.UnsignedInt> G,
    ffi.Pointer<ffi.UnsignedInt> B,
    ffi.Pointer<ffi.UnsignedInt> A,
  ) {
    return _FPDFText_GetStrokeColor(
      text_page,
      index,
      R,
      G,
      B,
      A,
    );
  }

  late final _FPDFText_GetStrokeColorPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('FPDFText_GetStrokeColor');
  late final _FPDFText_GetStrokeColor = _FPDFText_GetStrokeColorPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Experimental API.
  /// Function: FPDFText_GetCharAngle
  /// Get character rotation angle.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// Return Value:
  /// On success, return the angle value in radian. Value will always be
  /// greater or equal to 0. If |text_page| is invalid, or if |index| is
  /// out of bounds, then return -1.
  double FPDFText_GetCharAngle(
    FPDF_TEXTPAGE text_page,
    int index,
  ) {
    return _FPDFText_GetCharAngle(
      text_page,
      index,
    );
  }

  late final _FPDFText_GetCharAnglePtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(FPDF_TEXTPAGE, ffi.Int)>>(
          'FPDFText_GetCharAngle');
  late final _FPDFText_GetCharAngle = _FPDFText_GetCharAnglePtr.asFunction<
      double Function(FPDF_TEXTPAGE, int)>();

  /// Function: FPDFText_GetCharBox
  /// Get bounding box of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// left        -   Pointer to a double number receiving left position
  /// of the character box.
  /// right       -   Pointer to a double number receiving right position
  /// of the character box.
  /// bottom      -   Pointer to a double number receiving bottom position
  /// of the character box.
  /// top         -   Pointer to a double number receiving top position of
  /// the character box.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |right|, |bottom|, and
  /// |top|. If |text_page| is invalid, or if |index| is out of bounds,
  /// then return FALSE, and the out parameters remain unmodified.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int FPDFText_GetCharBox(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
    ffi.Pointer<ffi.Double> top,
  ) {
    return _FPDFText_GetCharBox(
      text_page,
      index,
      left,
      right,
      bottom,
      top,
    );
  }

  late final _FPDFText_GetCharBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDFText_GetCharBox');
  late final _FPDFText_GetCharBox = _FPDFText_GetCharBoxPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Experimental API.
  /// Function: FPDFText_GetLooseCharBox
  /// Get a "loose" bounding box of a particular character, i.e., covering
  /// the entire glyph bounds, without taking the actual glyph shape into
  /// account.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// rect        -   Pointer to a FS_RECTF receiving the character box.
  /// Return Value:
  /// On success, return TRUE and fill in |rect|. If |text_page| is
  /// invalid, or if |index| is out of bounds, then return FALSE, and the
  /// |rect| out parameter remains unmodified.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int FPDFText_GetLooseCharBox(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<FS_RECTF> rect,
  ) {
    return _FPDFText_GetLooseCharBox(
      text_page,
      index,
      rect,
    );
  }

  late final _FPDFText_GetLooseCharBoxPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int,
              ffi.Pointer<FS_RECTF>)>>('FPDFText_GetLooseCharBox');
  late final _FPDFText_GetLooseCharBox = _FPDFText_GetLooseCharBoxPtr
      .asFunction<int Function(FPDF_TEXTPAGE, int, ffi.Pointer<FS_RECTF>)>();

  /// Experimental API.
  /// Function: FPDFText_GetMatrix
  /// Get the effective transformation matrix for a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage().
  /// index       -   Zero-based index of the character.
  /// matrix      -   Pointer to a FS_MATRIX receiving the transformation
  /// matrix.
  /// Return Value:
  /// On success, return TRUE and fill in |matrix|. If |text_page| is
  /// invalid, or if |index| is out of bounds, or if |matrix| is NULL,
  /// then return FALSE, and |matrix| remains unmodified.
  int FPDFText_GetMatrix(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<FS_MATRIX> matrix,
  ) {
    return _FPDFText_GetMatrix(
      text_page,
      index,
      matrix,
    );
  }

  late final _FPDFText_GetMatrixPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int,
              ffi.Pointer<FS_MATRIX>)>>('FPDFText_GetMatrix');
  late final _FPDFText_GetMatrix = _FPDFText_GetMatrixPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<FS_MATRIX>)>();

  /// Function: FPDFText_GetCharOrigin
  /// Get origin of a particular character.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// index       -   Zero-based index of the character.
  /// x           -   Pointer to a double number receiving x coordinate of
  /// the character origin.
  /// y           -   Pointer to a double number receiving y coordinate of
  /// the character origin.
  /// Return Value:
  /// Whether the call succeeded. If false, x and y are unchanged.
  /// Comments:
  /// All positions are measured in PDF "user space".
  int FPDFText_GetCharOrigin(
    FPDF_TEXTPAGE text_page,
    int index,
    ffi.Pointer<ffi.Double> x,
    ffi.Pointer<ffi.Double> y,
  ) {
    return _FPDFText_GetCharOrigin(
      text_page,
      index,
      x,
      y,
    );
  }

  late final _FPDFText_GetCharOriginPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_TEXTPAGE, ffi.Int, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDFText_GetCharOrigin');
  late final _FPDFText_GetCharOrigin = _FPDFText_GetCharOriginPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDFText_GetCharIndexAtPos
  /// Get the index of a character at or nearby a certain position on the
  /// page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// x           -   X position in PDF "user space".
  /// y           -   Y position in PDF "user space".
  /// xTolerance  -   An x-axis tolerance value for character hit
  /// detection, in point units.
  /// yTolerance  -   A y-axis tolerance value for character hit
  /// detection, in point units.
  /// Return Value:
  /// The zero-based index of the character at, or nearby the point (x,y).
  /// If there is no character at or nearby the point, return value will
  /// be -1. If an error occurs, -3 will be returned.
  int FPDFText_GetCharIndexAtPos(
    FPDF_TEXTPAGE text_page,
    double x,
    double y,
    double xTolerance,
    double yTolerance,
  ) {
    return _FPDFText_GetCharIndexAtPos(
      text_page,
      x,
      y,
      xTolerance,
      yTolerance,
    );
  }

  late final _FPDFText_GetCharIndexAtPosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_TEXTPAGE, ffi.Double, ffi.Double, ffi.Double,
              ffi.Double)>>('FPDFText_GetCharIndexAtPos');
  late final _FPDFText_GetCharIndexAtPos =
      _FPDFText_GetCharIndexAtPosPtr.asFunction<
          int Function(FPDF_TEXTPAGE, double, double, double, double)>();

  /// Function: FPDFText_GetText
  /// Extract unicode text string from the page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// start_index -   Index for the start characters.
  /// count       -   Number of characters to be extracted.
  /// result      -   A buffer (allocated by application) receiving the
  /// extracted unicodes. The size of the buffer must be
  /// able to hold the number of characters plus a
  /// terminator.
  /// Return Value:
  /// Number of characters written into the result buffer, including the
  /// trailing terminator.
  /// Comments:
  /// This function ignores characters without unicode information.
  /// It returns all characters on the page, even those that are not
  /// visible when the page has a cropbox. To filter out the characters
  /// outside of the cropbox, use FPDF_GetPageBoundingBox() and
  /// FPDFText_GetCharBox().
  int FPDFText_GetText(
    FPDF_TEXTPAGE text_page,
    int start_index,
    int count,
    ffi.Pointer<ffi.UnsignedShort> result,
  ) {
    return _FPDFText_GetText(
      text_page,
      start_index,
      count,
      result,
    );
  }

  late final _FPDFText_GetTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_TEXTPAGE, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('FPDFText_GetText');
  late final _FPDFText_GetText = _FPDFText_GetTextPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// Function: FPDFText_CountRects
  /// Counts number of rectangular areas occupied by a segment of text,
  /// and caches the result for subsequent FPDFText_GetRect() calls.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// start_index -   Index for the start character.
  /// count       -   Number of characters, or -1 for all remaining.
  /// Return value:
  /// Number of rectangles, 0 if text_page is null, or -1 on bad
  /// start_index.
  /// Comments:
  /// This function, along with FPDFText_GetRect can be used by
  /// applications to detect the position on the page for a text segment,
  /// so proper areas can be highlighted. The FPDFText_* functions will
  /// automatically merge small character boxes into bigger one if those
  /// characters are on the same line and use same font settings.
  int FPDFText_CountRects(
    FPDF_TEXTPAGE text_page,
    int start_index,
    int count,
  ) {
    return _FPDFText_CountRects(
      text_page,
      start_index,
      count,
    );
  }

  late final _FPDFText_CountRectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              FPDF_TEXTPAGE, ffi.Int, ffi.Int)>>('FPDFText_CountRects');
  late final _FPDFText_CountRects = _FPDFText_CountRectsPtr.asFunction<
      int Function(FPDF_TEXTPAGE, int, int)>();

  /// Function: FPDFText_GetRect
  /// Get a rectangular area from the result generated by
  /// FPDFText_CountRects.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// rect_index  -   Zero-based index for the rectangle.
  /// left        -   Pointer to a double value receiving the rectangle
  /// left boundary.
  /// top         -   Pointer to a double value receiving the rectangle
  /// top boundary.
  /// right       -   Pointer to a double value receiving the rectangle
  /// right boundary.
  /// bottom      -   Pointer to a double value receiving the rectangle
  /// bottom boundary.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |top|, |right|, and
  /// |bottom|. If |text_page| is invalid then return FALSE, and the out
  /// parameters remain unmodified. If |text_page| is valid but
  /// |rect_index| is out of bounds, then return FALSE and set the out
  /// parameters to 0.
  int FPDFText_GetRect(
    FPDF_TEXTPAGE text_page,
    int rect_index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> top,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
  ) {
    return _FPDFText_GetRect(
      text_page,
      rect_index,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _FPDFText_GetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_TEXTPAGE,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDFText_GetRect');
  late final _FPDFText_GetRect = _FPDFText_GetRectPtr.asFunction<
      int Function(
          FPDF_TEXTPAGE,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Function: FPDFText_GetBoundedText
  /// Extract unicode text within a rectangular boundary on the page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// left        -   Left boundary.
  /// top         -   Top boundary.
  /// right       -   Right boundary.
  /// bottom      -   Bottom boundary.
  /// buffer      -   A unicode buffer.
  /// buflen      -   Number of characters (not bytes) for the buffer,
  /// excluding an additional terminator.
  /// Return Value:
  /// If buffer is NULL or buflen is zero, return number of characters
  /// (not bytes) of text present within the rectangle, excluding a
  /// terminating NUL. Generally you should pass a buffer at least one
  /// larger than this if you want a terminating NUL, which will be
  /// provided if space is available. Otherwise, return number of
  /// characters copied into the buffer, including the terminating NUL
  /// when space for it is available.
  /// Comment:
  /// If the buffer is too small, as much text as will fit is copied into
  /// it.
  int FPDFText_GetBoundedText(
    FPDF_TEXTPAGE text_page,
    double left,
    double top,
    double right,
    double bottom,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int buflen,
  ) {
    return _FPDFText_GetBoundedText(
      text_page,
      left,
      top,
      right,
      bottom,
      buffer,
      buflen,
    );
  }

  late final _FPDFText_GetBoundedTextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              FPDF_TEXTPAGE,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int)>>('FPDFText_GetBoundedText');
  late final _FPDFText_GetBoundedText = _FPDFText_GetBoundedTextPtr.asFunction<
      int Function(FPDF_TEXTPAGE, double, double, double, double,
          ffi.Pointer<ffi.UnsignedShort>, int)>();

  /// Function: FPDFText_FindStart
  /// Start a search.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// findwhat    -   A unicode match pattern.
  /// flags       -   Option flags.
  /// start_index -   Start from this character. -1 for end of the page.
  /// Return Value:
  /// A handle for the search context. FPDFText_FindClose must be called
  /// to release this handle.
  FPDF_SCHHANDLE FPDFText_FindStart(
    FPDF_TEXTPAGE text_page,
    FPDF_WIDESTRING findwhat,
    int flags,
    int start_index,
  ) {
    return _FPDFText_FindStart(
      text_page,
      findwhat,
      flags,
      start_index,
    );
  }

  late final _FPDFText_FindStartPtr = _lookup<
      ffi.NativeFunction<
          FPDF_SCHHANDLE Function(FPDF_TEXTPAGE, FPDF_WIDESTRING,
              ffi.UnsignedLong, ffi.Int)>>('FPDFText_FindStart');
  late final _FPDFText_FindStart = _FPDFText_FindStartPtr.asFunction<
      FPDF_SCHHANDLE Function(FPDF_TEXTPAGE, FPDF_WIDESTRING, int, int)>();

  /// Function: FPDFText_FindNext
  /// Search in the direction from page start to end.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Whether a match is found.
  int FPDFText_FindNext(
    FPDF_SCHHANDLE handle,
  ) {
    return _FPDFText_FindNext(
      handle,
    );
  }

  late final _FPDFText_FindNextPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_SCHHANDLE)>>(
          'FPDFText_FindNext');
  late final _FPDFText_FindNext =
      _FPDFText_FindNextPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_FindPrev
  /// Search in the direction from page end to start.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Whether a match is found.
  int FPDFText_FindPrev(
    FPDF_SCHHANDLE handle,
  ) {
    return _FPDFText_FindPrev(
      handle,
    );
  }

  late final _FPDFText_FindPrevPtr =
      _lookup<ffi.NativeFunction<FPDF_BOOL Function(FPDF_SCHHANDLE)>>(
          'FPDFText_FindPrev');
  late final _FPDFText_FindPrev =
      _FPDFText_FindPrevPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_GetSchResultIndex
  /// Get the starting character index of the search result.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Index for the starting character.
  int FPDFText_GetSchResultIndex(
    FPDF_SCHHANDLE handle,
  ) {
    return _FPDFText_GetSchResultIndex(
      handle,
    );
  }

  late final _FPDFText_GetSchResultIndexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_SCHHANDLE)>>(
          'FPDFText_GetSchResultIndex');
  late final _FPDFText_GetSchResultIndex =
      _FPDFText_GetSchResultIndexPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_GetSchCount
  /// Get the number of matched characters in the search result.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// Number of matched characters.
  int FPDFText_GetSchCount(
    FPDF_SCHHANDLE handle,
  ) {
    return _FPDFText_GetSchCount(
      handle,
    );
  }

  late final _FPDFText_GetSchCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_SCHHANDLE)>>(
          'FPDFText_GetSchCount');
  late final _FPDFText_GetSchCount =
      _FPDFText_GetSchCountPtr.asFunction<int Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFText_FindClose
  /// Release a search context.
  /// Parameters:
  /// handle      -   A search context handle returned by
  /// FPDFText_FindStart.
  /// Return Value:
  /// None.
  void FPDFText_FindClose(
    FPDF_SCHHANDLE handle,
  ) {
    return _FPDFText_FindClose(
      handle,
    );
  }

  late final _FPDFText_FindClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_SCHHANDLE)>>(
          'FPDFText_FindClose');
  late final _FPDFText_FindClose =
      _FPDFText_FindClosePtr.asFunction<void Function(FPDF_SCHHANDLE)>();

  /// Function: FPDFLink_LoadWebLinks
  /// Prepare information about weblinks in a page.
  /// Parameters:
  /// text_page   -   Handle to a text page information structure.
  /// Returned by FPDFText_LoadPage function.
  /// Return Value:
  /// A handle to the page's links information structure, or
  /// NULL if something goes wrong.
  /// Comments:
  /// Weblinks are those links implicitly embedded in PDF pages. PDF also
  /// has a type of annotation called "link" (FPDFTEXT doesn't deal with
  /// that kind of link). FPDFTEXT weblink feature is useful for
  /// automatically detecting links in the page contents. For example,
  /// things like "https://www.example.com" will be detected, so
  /// applications can allow user to click on those characters to activate
  /// the link, even the PDF doesn't come with link annotations.
  ///
  /// FPDFLink_CloseWebLinks must be called to release resources.
  FPDF_PAGELINK FPDFLink_LoadWebLinks(
    FPDF_TEXTPAGE text_page,
  ) {
    return _FPDFLink_LoadWebLinks(
      text_page,
    );
  }

  late final _FPDFLink_LoadWebLinksPtr =
      _lookup<ffi.NativeFunction<FPDF_PAGELINK Function(FPDF_TEXTPAGE)>>(
          'FPDFLink_LoadWebLinks');
  late final _FPDFLink_LoadWebLinks = _FPDFLink_LoadWebLinksPtr.asFunction<
      FPDF_PAGELINK Function(FPDF_TEXTPAGE)>();

  /// Function: FPDFLink_CountWebLinks
  /// Count number of detected web links.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// Return Value:
  /// Number of detected web links.
  int FPDFLink_CountWebLinks(
    FPDF_PAGELINK link_page,
  ) {
    return _FPDFLink_CountWebLinks(
      link_page,
    );
  }

  late final _FPDFLink_CountWebLinksPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGELINK)>>(
          'FPDFLink_CountWebLinks');
  late final _FPDFLink_CountWebLinks =
      _FPDFLink_CountWebLinksPtr.asFunction<int Function(FPDF_PAGELINK)>();

  /// Function: FPDFLink_GetURL
  /// Fetch the URL information for a detected web link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// buffer      -   A unicode buffer for the result.
  /// buflen      -   Number of 16-bit code units (not bytes) for the
  /// buffer, including an additional terminator.
  /// Return Value:
  /// If |buffer| is NULL or |buflen| is zero, return the number of 16-bit
  /// code units (not bytes) needed to buffer the result (an additional
  /// terminator is included in this count).
  /// Otherwise, copy the result into |buffer|, truncating at |buflen| if
  /// the result is too large to fit, and return the number of 16-bit code
  /// units actually copied into the buffer (the additional terminator is
  /// also included in this count).
  /// If |link_index| does not correspond to a valid link, then the result
  /// is an empty string.
  int FPDFLink_GetURL(
    FPDF_PAGELINK link_page,
    int link_index,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int buflen,
  ) {
    return _FPDFLink_GetURL(
      link_page,
      link_index,
      buffer,
      buflen,
    );
  }

  late final _FPDFLink_GetURLPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(FPDF_PAGELINK, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>, ffi.Int)>>('FPDFLink_GetURL');
  late final _FPDFLink_GetURL = _FPDFLink_GetURLPtr.asFunction<
      int Function(FPDF_PAGELINK, int, ffi.Pointer<ffi.UnsignedShort>, int)>();

  /// Function: FPDFLink_CountRects
  /// Count number of rectangular areas for the link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// Return Value:
  /// Number of rectangular areas for the link.  If |link_index| does
  /// not correspond to a valid link, then 0 is returned.
  int FPDFLink_CountRects(
    FPDF_PAGELINK link_page,
    int link_index,
  ) {
    return _FPDFLink_CountRects(
      link_page,
      link_index,
    );
  }

  late final _FPDFLink_CountRectsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(FPDF_PAGELINK, ffi.Int)>>(
          'FPDFLink_CountRects');
  late final _FPDFLink_CountRects =
      _FPDFLink_CountRectsPtr.asFunction<int Function(FPDF_PAGELINK, int)>();

  /// Function: FPDFLink_GetRect
  /// Fetch the boundaries of a rectangle for a link.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index  -   Zero-based index for the link.
  /// rect_index  -   Zero-based index for a rectangle.
  /// left        -   Pointer to a double value receiving the rectangle
  /// left boundary.
  /// top         -   Pointer to a double value receiving the rectangle
  /// top boundary.
  /// right       -   Pointer to a double value receiving the rectangle
  /// right boundary.
  /// bottom      -   Pointer to a double value receiving the rectangle
  /// bottom boundary.
  /// Return Value:
  /// On success, return TRUE and fill in |left|, |top|, |right|, and
  /// |bottom|. If |link_page| is invalid or if |link_index| does not
  /// correspond to a valid link, then return FALSE, and the out
  /// parameters remain unmodified.
  int FPDFLink_GetRect(
    FPDF_PAGELINK link_page,
    int link_index,
    int rect_index,
    ffi.Pointer<ffi.Double> left,
    ffi.Pointer<ffi.Double> top,
    ffi.Pointer<ffi.Double> right,
    ffi.Pointer<ffi.Double> bottom,
  ) {
    return _FPDFLink_GetRect(
      link_page,
      link_index,
      rect_index,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _FPDFLink_GetRectPtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(
              FPDF_PAGELINK,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>)>>('FPDFLink_GetRect');
  late final _FPDFLink_GetRect = _FPDFLink_GetRectPtr.asFunction<
      int Function(
          FPDF_PAGELINK,
          int,
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>)>();

  /// Experimental API.
  /// Function: FPDFLink_GetTextRange
  /// Fetch the start char index and char count for a link.
  /// Parameters:
  /// link_page         -   Handle returned by FPDFLink_LoadWebLinks.
  /// link_index        -   Zero-based index for the link.
  /// start_char_index  -   pointer to int receiving the start char index
  /// char_count        -   pointer to int receiving the char count
  /// Return Value:
  /// On success, return TRUE and fill in |start_char_index| and
  /// |char_count|. if |link_page| is invalid or if |link_index| does
  /// not correspond to a valid link, then return FALSE and the out
  /// parameters remain unmodified.
  int FPDFLink_GetTextRange(
    FPDF_PAGELINK link_page,
    int link_index,
    ffi.Pointer<ffi.Int> start_char_index,
    ffi.Pointer<ffi.Int> char_count,
  ) {
    return _FPDFLink_GetTextRange(
      link_page,
      link_index,
      start_char_index,
      char_count,
    );
  }

  late final _FPDFLink_GetTextRangePtr = _lookup<
      ffi.NativeFunction<
          FPDF_BOOL Function(FPDF_PAGELINK, ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('FPDFLink_GetTextRange');
  late final _FPDFLink_GetTextRange = _FPDFLink_GetTextRangePtr.asFunction<
      int Function(
          FPDF_PAGELINK, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Function: FPDFLink_CloseWebLinks
  /// Release resources used by weblink feature.
  /// Parameters:
  /// link_page   -   Handle returned by FPDFLink_LoadWebLinks.
  /// Return Value:
  /// None.
  void FPDFLink_CloseWebLinks(
    FPDF_PAGELINK link_page,
  ) {
    return _FPDFLink_CloseWebLinks(
      link_page,
    );
  }

  late final _FPDFLink_CloseWebLinksPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(FPDF_PAGELINK)>>(
          'FPDFLink_CloseWebLinks');
  late final _FPDFLink_CloseWebLinks =
      _FPDFLink_CloseWebLinksPtr.asFunction<void Function(FPDF_PAGELINK)>();
}

/// PDF text rendering modes
abstract class FPDF_TEXT_RENDERMODE {
  static const int FPDF_TEXTRENDERMODE_UNKNOWN = -1;
  static const int FPDF_TEXTRENDERMODE_FILL = 0;
  static const int FPDF_TEXTRENDERMODE_STROKE = 1;
  static const int FPDF_TEXTRENDERMODE_FILL_STROKE = 2;
  static const int FPDF_TEXTRENDERMODE_INVISIBLE = 3;
  static const int FPDF_TEXTRENDERMODE_FILL_CLIP = 4;
  static const int FPDF_TEXTRENDERMODE_STROKE_CLIP = 5;
  static const int FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP = 6;
  static const int FPDF_TEXTRENDERMODE_CLIP = 7;
  static const int FPDF_TEXTRENDERMODE_LAST = 7;
}

final class fpdf_action_t__ extends ffi.Opaque {}

final class fpdf_annotation_t__ extends ffi.Opaque {}

final class fpdf_attachment_t__ extends ffi.Opaque {}

final class fpdf_avail_t__ extends ffi.Opaque {}

final class fpdf_bitmap_t__ extends ffi.Opaque {}

final class fpdf_bookmark_t__ extends ffi.Opaque {}

final class fpdf_clippath_t__ extends ffi.Opaque {}

final class fpdf_dest_t__ extends ffi.Opaque {}

final class fpdf_document_t__ extends ffi.Opaque {}

final class fpdf_font_t__ extends ffi.Opaque {}

final class fpdf_form_handle_t__ extends ffi.Opaque {}

final class fpdf_glyphpath_t__ extends ffi.Opaque {}

final class fpdf_javascript_action_t extends ffi.Opaque {}

final class fpdf_link_t__ extends ffi.Opaque {}

final class fpdf_page_t__ extends ffi.Opaque {}

final class fpdf_pagelink_t__ extends ffi.Opaque {}

final class fpdf_pageobject_t__ extends ffi.Opaque {}

final class fpdf_pageobjectmark_t__ extends ffi.Opaque {}

final class fpdf_pagerange_t__ extends ffi.Opaque {}

final class fpdf_pathsegment_t extends ffi.Opaque {}

final class fpdf_schhandle_t__ extends ffi.Opaque {}

final class fpdf_signature_t__ extends ffi.Opaque {}

final class fpdf_structelement_t__ extends ffi.Opaque {}

final class fpdf_structelement_attr_t__ extends ffi.Opaque {}

final class fpdf_structtree_t__ extends ffi.Opaque {}

final class fpdf_textpage_t__ extends ffi.Opaque {}

final class fpdf_widget_t__ extends ffi.Opaque {}

final class fpdf_xobject_t__ extends ffi.Opaque {}

/// Duplex types
abstract class _FPDF_DUPLEXTYPE_ {
  static const int DuplexUndefined = 0;
  static const int Simplex = 1;
  static const int DuplexFlipShortEdge = 2;
  static const int DuplexFlipLongEdge = 3;
}

/// Structure for persisting a string beyond the duration of a callback.
/// Note: although represented as a char*, string may be interpreted as
/// a UTF-16LE formated string. Used only by XFA callbacks.
final class FPDF_BSTR_ extends ffi.Struct {
  /// String buffer, manipulate only with FPDF_BStr_* methods.
  external ffi.Pointer<ffi.Char> str;

  /// Length of the string, in bytes.
  @ffi.Int()
  external int len;
}

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
final class _FS_MATRIX_ extends ffi.Struct {
  @ffi.Float()
  external double a;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double c;

  @ffi.Float()
  external double d;

  @ffi.Float()
  external double e;

  @ffi.Float()
  external double f;
}

/// Rectangle area(float) in device or page coordinate system.
final class _FS_RECTF_ extends ffi.Struct {
  /// The x-coordinate of the left-top corner.
  @ffi.Float()
  external double left;

  /// The y-coordinate of the left-top corner.
  @ffi.Float()
  external double top;

  /// The x-coordinate of the right-bottom corner.
  @ffi.Float()
  external double right;

  /// The y-coordinate of the right-bottom corner.
  @ffi.Float()
  external double bottom;
}

/// Rectangle size. Coordinate system agnostic.
final class FS_SIZEF_ extends ffi.Struct {
  @ffi.Float()
  external double width;

  @ffi.Float()
  external double height;
}

/// 2D Point. Coordinate system agnostic.
final class FS_POINTF_ extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

final class _FS_QUADPOINTSF extends ffi.Struct {
  @FS_FLOAT()
  external double x1;

  @FS_FLOAT()
  external double y1;

  @FS_FLOAT()
  external double x2;

  @FS_FLOAT()
  external double y2;

  @FS_FLOAT()
  external double x3;

  @FS_FLOAT()
  external double y3;

  @FS_FLOAT()
  external double x4;

  @FS_FLOAT()
  external double y4;
}

typedef FS_FLOAT = ffi.Float;

/// PDF renderer types - Experimental.
/// Selection of 2D graphics library to use for rendering to FPDF_BITMAPs.
abstract class FPDF_RENDERER_TYPE {
  /// Anti-Grain Geometry - https://sourceforge.net/projects/agg/
  static const int FPDF_RENDERERTYPE_AGG = 0;

  /// Skia - https://skia.org/
  static const int FPDF_RENDERERTYPE_SKIA = 1;
}

/// Process-wide options for initializing the library.
final class FPDF_LIBRARY_CONFIG_ extends ffi.Struct {
  /// Version number of the interface. Currently must be 2.
  /// Support for version 1 will be deprecated in the future.
  @ffi.Int()
  external int version;

  /// Array of paths to scan in place of the defaults when using built-in
  /// FXGE font loading code. The array is terminated by a NULL pointer.
  /// The Array may be NULL itself to use the default paths. May be ignored
  /// entirely depending upon the platform.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> m_pUserFontPaths;

  /// Pointer to the v8::Isolate to use, or NULL to force PDFium to create one.
  external ffi.Pointer<ffi.Void> m_pIsolate;

  /// The embedder data slot to use in the v8::Isolate to store PDFium's
  /// per-isolate data. The value needs to be in the range
  /// [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most
  /// embedders.
  @ffi.UnsignedInt()
  external int m_v8EmbedderSlot;

  /// Pointer to the V8::Platform to use.
  external ffi.Pointer<ffi.Void> m_pPlatform;

  /// Explicit specification of core renderer to use. |m_RendererType| must be
  /// a valid value for |FPDF_LIBRARY_CONFIG| versions of this level or higher,
  /// or else the initialization will fail with an immediate crash.
  /// Note that use of a specified |FPDF_RENDERER_TYPE| value for which the
  /// corresponding render library is not included in the build will similarly
  /// fail with an immediate crash.
  @ffi.Int32()
  external int m_RendererType;
}

/// Process-wide options for initializing the library.
typedef FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;
typedef FPDF_DWORD = ffi.UnsignedLong;

/// Basic data types
typedef FPDF_BOOL = ffi.Int;
typedef FPDF_DOCUMENT = ffi.Pointer<fpdf_document_t__>;

/// For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a
/// Windows unicode string, however, special care needs to be taken if you
/// expect to process Unicode larger than 0xffff.
///
/// For Linux/Unix programmers: most compiler/library environments use 4 bytes
/// for a Unicode character, and you have to convert between FPDF_WIDESTRING and
/// system wide string by yourself.
typedef FPDF_STRING = ffi.Pointer<ffi.Char>;

/// FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE
/// encoded), and platform dependent string
typedef FPDF_BYTESTRING = ffi.Pointer<ffi.Char>;

/// Structure for custom file access.
final class FPDF_FILEACCESS extends ffi.Struct {
  /// File length, in bytes.
  @ffi.UnsignedLong()
  external int m_FileLen;

  /// A function pointer for getting a block of data from a specific position.
  /// Position is specified by byte offset from the beginning of the file.
  /// The pointer to the buffer is never NULL and the size is never 0.
  /// The position and size will never go out of range of the file length.
  /// It may be possible for FPDFSDK to call this function multiple times for
  /// the same position.
  /// Return value: should be non-zero if successful, zero for error.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> param,
              ffi.UnsignedLong position,
              ffi.Pointer<ffi.UnsignedChar> pBuf,
              ffi.UnsignedLong size)>> m_GetBlock;

  /// A custom pointer for all implementation specific data.  This pointer will
  /// be used as the first parameter to the m_GetBlock callback.
  external ffi.Pointer<ffi.Void> m_Param;
}

/// Structure for file reading or writing (I/O).
///
/// Note: This is a handler and should be implemented by callers,
/// and is only used from XFA.
final class FPDF_FILEHANDLER_ extends ffi.Struct {
  /// User-defined data.
  /// Note: Callers can use this field to track controls.
  external ffi.Pointer<ffi.Void> clientData;

  /// Callback function to release the current file stream object.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// None.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> clientData)>> Release;

  /// Callback function to retrieve the current file stream size.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// Size of file stream.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_DWORD Function(ffi.Pointer<ffi.Void> clientData)>> GetSize;

  /// Callback function to read data from the current file stream.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// offset       -  Offset position starts from the beginning of file
  /// stream. This parameter indicates reading position.
  /// buffer       -  Memory buffer to store data which are read from
  /// file stream. This parameter should not be NULL.
  /// size         -  Size of data which should be read from file stream,
  /// in bytes. The buffer indicated by |buffer| must be
  /// large enough to store specified data.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData,
              FPDF_DWORD offset,
              ffi.Pointer<ffi.Void> buffer,
              FPDF_DWORD size)>> ReadBlock;

  /// Callback function to write data into the current file stream.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// offset       -  Offset position starts from the beginning of file
  /// stream. This parameter indicates writing position.
  /// buffer       -  Memory buffer contains data which is written into
  /// file stream. This parameter should not be NULL.
  /// size         -  Size of data which should be written into file
  /// stream, in bytes.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData,
              FPDF_DWORD offset,
              ffi.Pointer<ffi.Void> buffer,
              FPDF_DWORD size)>> WriteBlock;

  /// Callback function to flush all internal accessing buffers.
  ///
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(ffi.Pointer<ffi.Void> clientData)>> Flush;

  /// Callback function to change file size.
  ///
  /// Description:
  /// This function is called under writing mode usually. Implementer
  /// can determine whether to realize it based on application requests.
  /// Parameters:
  /// clientData   -  Pointer to user-defined data.
  /// size         -  New size of file stream, in bytes.
  /// Returns:
  /// 0 for success, other value for failure.
  external ffi.Pointer<
      ffi.NativeFunction<
          FPDF_RESULT Function(
              ffi.Pointer<ffi.Void> clientData, FPDF_DWORD size)>> Truncate;
}

typedef FPDF_RESULT = ffi.Int;
typedef FPDF_PAGE = ffi.Pointer<fpdf_page_t__>;

/// Rectangle area(float) in device or page coordinate system.
typedef FS_RECTF = _FS_RECTF_;

/// Rectangle size. Coordinate system agnostic.
typedef FS_SIZEF = FS_SIZEF_;

/// Struct for color scheme.
/// Each should be a 32-bit value specifying the color, in 8888 ARGB format.
final class FPDF_COLORSCHEME_ extends ffi.Struct {
  @FPDF_DWORD()
  external int path_fill_color;

  @FPDF_DWORD()
  external int path_stroke_color;

  @FPDF_DWORD()
  external int text_fill_color;

  @FPDF_DWORD()
  external int text_stroke_color;
}

typedef HDC = ffi.Pointer<HDC__>;

final class HDC__ extends ffi.Struct {
  @ffi.Int()
  external int unused;
}

typedef FPDF_BITMAP = ffi.Pointer<fpdf_bitmap_t__>;

/// Matrix for transformation, in the form [a b c d e f], equivalent to:
/// | a  b  0 |
/// | c  d  0 |
/// | e  f  1 |
///
/// Translation is performed with [1 0 0 1 tx ty].
/// Scaling is performed with [sx 0 0 sy 0 0].
/// See PDF Reference 1.7, 4.2.2 Common Transformations for more.
typedef FS_MATRIX = _FS_MATRIX_;
typedef FPDF_PAGERANGE = ffi.Pointer<fpdf_pagerange_t__>;
typedef FPDF_DEST = ffi.Pointer<fpdf_dest_t__>;
typedef FPDF_TEXTPAGE = ffi.Pointer<fpdf_textpage_t__>;
typedef FPDF_SCHHANDLE = ffi.Pointer<fpdf_schhandle_t__>;

/// FPDFSDK always uses UTF-16LE encoded wide strings, each character uses 2
/// bytes (except surrogation), with the low byte first.
typedef FPDF_WIDESTRING = ffi.Pointer<FPDF_WCHAR>;

/// String types
typedef FPDF_WCHAR = ffi.UnsignedShort;
typedef FPDF_PAGELINK = ffi.Pointer<fpdf_pagelink_t__>;

const int FPDF_OBJECT_UNKNOWN = 0;

const int FPDF_OBJECT_BOOLEAN = 1;

const int FPDF_OBJECT_NUMBER = 2;

const int FPDF_OBJECT_STRING = 3;

const int FPDF_OBJECT_NAME = 4;

const int FPDF_OBJECT_ARRAY = 5;

const int FPDF_OBJECT_DICTIONARY = 6;

const int FPDF_OBJECT_STREAM = 7;

const int FPDF_OBJECT_NULLOBJ = 8;

const int FPDF_OBJECT_REFERENCE = 9;

const int FPDF_POLICY_MACHINETIME_ACCESS = 0;

const int FPDF_ERR_SUCCESS = 0;

const int FPDF_ERR_UNKNOWN = 1;

const int FPDF_ERR_FILE = 2;

const int FPDF_ERR_FORMAT = 3;

const int FPDF_ERR_PASSWORD = 4;

const int FPDF_ERR_SECURITY = 5;

const int FPDF_ERR_PAGE = 6;

const int FPDF_ANNOT = 1;

const int FPDF_LCD_TEXT = 2;

const int FPDF_NO_NATIVETEXT = 4;

const int FPDF_GRAYSCALE = 8;

const int FPDF_DEBUG_INFO = 128;

const int FPDF_NO_CATCH = 256;

const int FPDF_RENDER_LIMITEDIMAGECACHE = 512;

const int FPDF_RENDER_FORCEHALFTONE = 1024;

const int FPDF_PRINTING = 2048;

const int FPDF_RENDER_NO_SMOOTHTEXT = 4096;

const int FPDF_RENDER_NO_SMOOTHIMAGE = 8192;

const int FPDF_RENDER_NO_SMOOTHPATH = 16384;

const int FPDF_REVERSE_BYTE_ORDER = 16;

const int FPDF_CONVERT_FILL_TO_STROKE = 32;

const int FPDFBitmap_Unknown = 0;

const int FPDFBitmap_Gray = 1;

const int FPDFBitmap_BGR = 2;

const int FPDFBitmap_BGRx = 3;

const int FPDFBitmap_BGRA = 4;

const int FPDF_MATCHCASE = 1;

const int FPDF_MATCHWHOLEWORD = 2;

const int FPDF_CONSECUTIVE = 4;
